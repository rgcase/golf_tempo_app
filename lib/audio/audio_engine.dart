import 'dart:async';
import 'dart:io';
import 'dart:typed_data';

import 'package:audio_session/audio_session.dart';
import 'package:flutter/services.dart' show rootBundle;
import 'package:just_audio/just_audio.dart';

class AudioEngine {
  AudioPlayer? _player;
  bool _initialized = false;
  bool _isPlaying = false;
  double _volume = 1.0;

  // Current tempo config
  _TempoRuntimeConfig? _config;

  Future<void> init() async {
    if (_initialized) return;

    final session = await AudioSession.instance;
    await session.configure(
      const AudioSessionConfiguration(
        avAudioSessionCategory: AVAudioSessionCategory.playback,
        avAudioSessionCategoryOptions:
            AVAudioSessionCategoryOptions.mixWithOthers,
        avAudioSessionMode: AVAudioSessionMode.defaultMode,
        androidAudioAttributes: AndroidAudioAttributes(
          contentType: AndroidAudioContentType.music,
          usage: AndroidAudioUsage.media,
        ),
        androidWillPauseWhenDucked: false,
      ),
    );

    _initialized = true;
  }

  Future<void> setTempo({
    required int backswingUnits,
    required int downswingUnits,
    required Duration totalCycle,
  }) async {
    if (!_initialized) {
      await init();
    }
    _config = _TempoRuntimeConfig(
      backswingUnits: backswingUnits,
      downswingUnits: downswingUnits,
      totalCycle: totalCycle,
    );
    // If a player exists (e.g., while playing), update the source now; otherwise start() will apply it.
    if (_player != null) {
      await _applySource();
    }
  }

  Future<void> start() async {
    if (!_initialized) {
      await init();
    }
    if (_config == null) {
      // Provide a sensible default: 3:1 with 21:7 units and ~1.2s total cycle
      await setTempo(
        backswingUnits: 21,
        downswingUnits: 7,
        totalCycle: const Duration(milliseconds: 1200),
      );
    }
    if (_isPlaying) return;

    // (Re)create player fresh if needed, then set source and play
    _player ??= AudioPlayer();
    await _player!.setVolume(_volume);

    await _applySource();
    await _player!.setLoopMode(LoopMode.one);
    await _player!.play();
    _isPlaying = true;
  }

  Future<void> stop() async {
    if (!_initialized) return;
    if (!_isPlaying && _player == null) return;

    // Dispose the player to guarantee audio stops, and recreate lazily on next start
    try {
      await _player?.dispose();
    } finally {
      _player = null;
      _isPlaying = false;
    }
  }

  void setVolume(double volume) {
    _volume = volume.clamp(0.0, 1.0);
    _player?.setVolume(_volume);
  }

  bool get isPlaying => _isPlaying;

  bool _isValidPcmWav(Uint8List wav) {
    if (wav.length < 44) return false;
    // Check tags quickly
    bool matchTag(int offset, String tag) {
      final bytes = wav.sublist(offset, offset + 4);
      return String.fromCharCodes(bytes) == tag;
    }

    if (!matchTag(0, 'RIFF')) return false;
    if (!matchTag(8, 'WAVE')) return false;
    if (!matchTag(12, 'fmt ')) return false;
    if (!matchTag(36, 'data')) return false;
    return true;
  }

  Future<void> _applySource() async {
    if (_player == null || _config == null) return;
    final cfg = _config!;

    // Asset filename scheme generated by tools/generate_audio.dart, which includes 2s trailing gap.
    final ratioKey = cfg.backswingUnits ~/ cfg.downswingUnits == 3
        ? '3to1'
        : '2to1';
    final assetPath =
        'assets/audio/cycles/${ratioKey}_${cfg.backswingUnits}_${cfg.downswingUnits}.wav';

    // Copy asset to a temp file then load via URI to avoid platform asset handling differences
    final data = await rootBundle.load(assetPath);
    final bytes = data.buffer.asUint8List();
    if (!_isValidPcmWav(bytes)) {
      throw StateError('Invalid WAV asset at $assetPath');
    }
    final dir = await Directory.systemTemp.createTemp('golf_tempo_asset');
    final file = File('${dir.path}/cycle.wav');
    await file.writeAsBytes(bytes, flush: true);
    await _player!.setAudioSource(AudioSource.uri(Uri.file(file.path)));
  }
}

class _TempoRuntimeConfig {
  final int backswingUnits;
  final int downswingUnits;
  final Duration totalCycle;

  const _TempoRuntimeConfig({
    required this.backswingUnits,
    required this.downswingUnits,
    required this.totalCycle,
  });
}
